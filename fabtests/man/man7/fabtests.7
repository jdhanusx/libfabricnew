.\" Automatically generated by Pandoc 2.5
.\"
.TH "fabtests" "7" "2021\-06\-02" "Libfabric Programmer\[cq]s Manual" "#VERSION#"
.hy
.SH NAME
.PP
Fabtests
.SH SYNOPSIS
.PP
Fabtests is a set of examples for fabric providers that demonstrates
various features of libfabric\- high\-performance fabric software
library.
.SH OVERVIEW
.PP
Libfabric defines sets of interface that fabric providers can support.
The purpose of Fabtests examples is to demonstrate some of the major
features.
The goal is to familiarize users with different functionalities
libfabric offers and how to use them.
Although most tests report performance numbers, they are designed to
test functionality and not performance.
The exception are the benchmarks and ubertest.
.PP
The tests are divided into the following categories.
Except the unit tests all of them are client\-server tests.
Not all providers will support each test.
.PP
The test names try to indicate the type of functionality each test is
verifying.
Although some tests work with any endpoint type, many are restricted to
verifying a single endpoint type.
These tests typically include the endpoint type as part of the test
name, such as dgram, msg, or rdm.
.SH Functional
.PP
These tests are a mix of very basic functionality tests that show major
features of libfabric.
.TP
.B \f[I]fi_av_xfer\f[R]
Tests communication for connectionless endpoints, as addresses are
inserted and removed from the local address vector.
.TP
.B \f[I]fi_cm_data\f[R]
Verifies exchanging CM data as part of connecting endpoints.
.TP
.B \f[I]fi_cq_data\f[R]
Tranfers messages with CQ data.
.TP
.B \f[I]fi_dgram\f[R]
A basic datagram endpoint example.
.TP
.B \f[I]fi_dgram_waitset\f[R]
Transfers datagrams using waitsets for completion notification.
.TP
.B \f[I]fi_inj_complete\f[R]
Sends messages using the FI_INJECT_COMPLETE operation flag.
.TP
.B \f[I]fi_mcast\f[R]
A simple multicast test.
.TP
.B \f[I]fi_msg\f[R]
A basic message endpoint example.
.TP
.B \f[I]fi_msg_epoll\f[R]
Transfers messages with completion queues configured to use file
descriptors as wait objects.
The file descriptors are retrieved by the program and used directly with
the Linux epoll API.
.TP
.B \f[I]fi_msg_sockets\f[R]
Verifies that the address assigned to a passive endpoint can be
transitioned to an active endpoint.
This is required applications that need socket API semantics over RDMA
implementations (e.g.\ rsockets).
.TP
.B \f[I]fi_multi_ep\f[R]
Performs data transfers over multiple endpoints in parallel.
.TP
.B \f[I]fi_multi_mr\f[R]
Issues RMA write operations to multiple memory regions, using completion
counters of inbound writes as the notification mechanism.
.TP
.B \f[I]fi_poll\f[R]
Exchanges data over RDM endpoints using poll sets to drive completion
notifications.
.TP
.B \f[I]fi_rdm\f[R]
A basic RDM endpoint example.
.TP
.B \f[I]fi_rdm_atomic\f[R]
Test and verifies atomic operations over an RDM endpoint.
.TP
.B \f[I]fi_rdm_deferred_wq\f[R]
Test triggered operations and deferred work queue support.
.TP
.B \f[I]fi_rdm_multi_domain\f[R]
Performs data transfers over multiple endpoints, with each endpoint
belonging to a different opened domain.
.TP
.B \f[I]fi_rdm_multi_recv\f[R]
Transfers multiple messages over an RDM endpoint that are received into
a single buffer, posted using the FI_MULTI_RECV flag.
.TP
.B \f[I]fi_rdm_rma_event\f[R]
An RMA write example over an RDM endpoint that uses RMA events to notify
the peer that the RMA transfer has completed.
.TP
.B \f[I]fi_rdm_rma_trigger\f[R]
A basic example of queuing an RMA write operation that is initiated upon
the firing of a triggering completion.
Works with RDM endpoints.
.TP
.B \f[I]fi_rdm_shared_av\f[R]
Spawns child processes to verify basic functionality of using a shared
address vector with RDM endpoints.
.TP
.B \f[I]fi_rdm_tagged_peek\f[R]
Basic test of using the FI_PEEK operation flag with tagged messages.
Works with RDM endpoints.
.TP
.B \f[I]fi_recv_cancel\f[R]
Tests canceling posted receives for tagged messages.
.TP
.B \f[I]fi_resmgmt_test\f[R]
Tests the resource management enabled feature.
This verifies that the provider prevents applications from overrunning
local and remote command queues and completion queues.
This corresponds to setting the domain attribute resource_mgmt to
FI_RM_ENABLED.
.TP
.B \f[I]fi_scalable_ep\f[R]
Performs data transfers over scalable endpoints, endpoints associated
with multiple transmit and receive contexts.
.TP
.B \f[I]fi_shared_ctx\f[R]
Performs data transfers between multiple endpoints, where the endpoints
share transmit and/or receive contexts.
.TP
.B \f[I]fi_unexpected_msg\f[R]
Tests the send and receive handling of unexpected tagged messages.
.TP
.B \f[I]fi_unmap_mem\f[R]
Tests data transfers where the transmit buffer is mmapped and unmapped
between each transfer, but the virtual address of the transmit buffer
tries to remain the same.
This test is used to validate the correct behavior of memory
registration caches.
.TP
.B \f[I]fi_bw\f[R]
Performs a one\-sided bandwidth test with an option for data
verification.
A sleep time on the receiving side can be enabled in order to allow the
sender to get ahead of the receiver.
.SH Benchmarks
.PP
The client and the server exchange messages in either a ping\-pong
manner, for pingpong named tests, or transfer messages one\-way, for bw
named tests.
These tests can transfer various messages sizes, with controls over
which features are used by the test, and report performance numbers.
The tests are structured based on the benchmarks provided by OSU MPI.
They are not guaranteed to provide the best latency or bandwidth
performance numbers a given provider or system may achieve.
.TP
.B \f[I]fi_dgram_pingpong\f[R]
Latency test for datagram endpoints
.TP
.B \f[I]fi_msg_bw\f[R]
Message transfer bandwidth test for connected (MSG) endpoints.
.TP
.B \f[I]fi_msg_pingpong\f[R]
Message transfer latency test for connected (MSG) endpoints.
.TP
.B \f[I]fi_rdm_cntr_pingpong\f[R]
Message transfer latency test for reliable\-datagram (RDM) endpoints
that uses counters as the completion mechanism.
.TP
.B \f[I]fi_rdm_pingpong\f[R]
Message transfer latency test for reliable\-datagram (RDM) endpoints.
.TP
.B \f[I]fi_rdm_tagged_bw\f[R]
Tagged message bandwidth test for reliable\-datagram (RDM) endpoints.
.TP
.B \f[I]fi_rdm_tagged_pingpong\f[R]
Tagged message latency test for reliable\-datagram (RDM) endpoints.
.TP
.B \f[I]fi_rma_bw\f[R]
An RMA read and write bandwidth test for reliable (MSG and RDM)
endpoints.
.SH Unit
.PP
These are simple one\-sided unit tests that validate basic behavior of
the API.
Because these are single system tests that do not perform data transfers
their testing scope is limited.
.TP
.B \f[I]fi_av_test\f[R]
Verify address vector interfaces.
.TP
.B \f[I]fi_cntr_test\f[R]
Tests counter creation and destruction.
.TP
.B \f[I]fi_cq_test\f[R]
Tests completion queue creation and destruction.
.TP
.B \f[I]fi_dom_test\f[R]
Tests domain creation and destruction.
.TP
.B \f[I]fi_eq_test\f[R]
Tests event queue creation, destruction, and capabilities.
.TP
.B \f[I]fi_getinfo_test\f[R]
Tests provider response to fi_getinfo calls with varying hints.
.TP
.B \f[I]fi_mr_test\f[R]
Tests memory registration.
.TP
.B \f[I]fi_mr_cache_evict\f[R]
Tests provider MR cache eviction capabilities.
.SH Multinode
.PP
This test runs a series of tests over multiple formats and patterns to
help validate at scale.
The patterns are an all to all, one to all, all to one and a ring.
The tests also run across multiple capabilities, such as messages, rma,
atomics, and tagged messages.
Currently, there is no option to run these capabilities and patterns
independently, however the test is short enough to be all run at once.
.SH Ubertest
.PP
This is a comprehensive latency, bandwidth, and functionality test that
can handle a variety of test configurations.
The test is able to run a large number of tests by iterating over a
large number of test variables.
As a result, a full ubertest run can take a significant amount of time.
Because ubertest iterates over input variables, it relies on a test
configuration file for control, rather than extensive command line
options that are used by other fabtests.
A configuration file must be constructed for each provider.
Example test configurations are at test_configs.
.TP
.B \f[I]fi_ubertest\f[R]
This test takes a configure file as input.
The file contains a list of variables and their values to iterate over.
The test will run a set of latency, bandwidth, and functionality tests
over a given provider.
It will perform one execution for every possible combination of all
variables.
For example, if there are 8 test variables, with 6 having 2 possible
values and 2 having 3 possible values, ubertest will execute 576 total
iterations of each test.
.SS Config file options
.PP
The following keys and respective key values may be used in the config
file.
.TP
.B \f[I]prov_name\f[R]
Identify the provider(s) to test.
E.g.
udp, tcp, verbs, ofi_rxm;verbs; ofi_rxd;udp.
.TP
.B \f[I]test_type\f[R]
FT_TEST_LATENCY, FT_TEST_BANDWIDTH, FT_TEST_UNIT
.TP
.B \f[I]test_class\f[R]
FT_CAP_MSG, FT_CAP_TAGGED, FT_CAP_RMA, FT_CAP_ATOMIC
.TP
.B \f[I]class_function\f[R]
For FT_CAP_MSG and FT_CAP_TAGGED: FT_FUNC_SEND, FT_FUNC_SENDV,
FT_FUNC_SENDMSG, FT_FUNC_INJECT, FT_FUNC_INJECTDATA, FT_FUNC_SENDDATA
.PP
For FT_CAP_RMA: FT_FUNC_WRITE, FT_FUNC_WRITEV, FT_FUNC_WRITEMSG,
FT_FUNC_WRITEDATA, FT_FUNC_INJECT_WRITE, FT_FUNC_INJECT_WRITEDATA,
FT_FUNC_READ, FT_FUNC_READV, FT_FUNC_READMSG
.PP
For FT_CAP_ATOMIC: FT_FUNC_ATOMIC, FT_FUNC_ATOMICV, FT_FUNC_ATOMICMSG,
FT_FUNC_INJECT_ATOMIC, FT_FUNC_FETCH_ATOMIC, FT_FUNC_FETCH_ATOMICV,
FT_FUNC_FETCH_ATOMICMSG, FT_FUNC_COMPARE_ATOMIC,
FT_FUNC_COMPARE_ATOMICV, FT_FUNC_COMPARE_ATOMICMSG
.TP
.B \f[I]constant_caps \- values OR\[cq]ed together\f[R]
FI_RMA, FI_MSG, FI_SEND, FI_RECV, FI_READ, FI_WRITE, FI_REMOTE_READ,
FI_REMOTE_WRITE, FI_TAGGED, FI_DIRECTED_RECV
.TP
.B \f[I]mode \- values OR\[cq]ed together\f[R]
FI_CONTEXT, FI_RX_CQ_DATA
.TP
.B \f[I]ep_type\f[R]
FI_EP_MSG, FI_EP_DGRAM, FI_EP_RDM
.TP
.B \f[I]comp_type\f[R]
FT_COMP_QUEUE, FT_COMP_CNTR, FT_COMP_ALL
.TP
.B \f[I]av_type\f[R]
FI_AV_MAP, FI_AV_TABLE
.TP
.B \f[I]eq_wait_obj\f[R]
FI_WAIT_NONE, FI_WAIT_UNSPEC, FI_WAIT_FD, FI_WAIT_MUTEX_COND
.TP
.B \f[I]cq_wait_obj\f[R]
FI_WAIT_NONE, FI_WAIT_UNSPEC, FI_WAIT_FD, FI_WAIT_MUTEX_COND
.TP
.B \f[I]cntr_wait_obj\f[R]
FI_WAIT_NONE, FI_WAIT_UNSPEC, FI_WAIT_FD, FI_WAIT_MUTEX_COND
.TP
.B \f[I]threading\f[R]
FI_THREAD_UNSPEC, FI_THREAD_SAFE, FI_THREAD_FID, FI_THREAD_DOMAIN,
FI_THREAD_COMPLETION, FI_THREAD_ENDPOINT
.TP
.B \f[I]progress\f[R]
FI_PROGRESS_MANUAL, FI_PROGRESS_AUTO, FI_PROGRESS_UNSPEC
.TP
.B \f[I]mr_mode\f[R]
(Values OR\[cq]ed together) FI_MR_LOCAL, FI_MR_VIRT_ADDR,
FI_MR_ALLOCATED, FI_MR_PROV_KEY
.TP
.B \f[I]op\f[R]
For FT_CAP_ATOMIC: FI_MIN, FI_MAX, FI_SUM, FI_PROD, FI_LOR, FI_LAND,
FI_BOR, FI_BAND, FI_LXOR, FI_BXOR, FI_ATOMIC_READ, FI_ATOMIC_WRITE,
FI_CSWAP, FI_CSWAP_NE, FI_CSWAP_LE, FI_CSWAP_LT, FI_CSWAP_GE,
FI_CSWAP_GT, FI_MSWAP
.TP
.B \f[I]datatype\f[R]
For FT_CAP_ATOMIC: FI_INT8, FI_UINT8, FI_INT16, FI_UINT16, FI_INT32,
FI_UINT32, FI_INT64, FI_UINT64, FI_INT128, FI_UINT128, FI_FLOAT,
FI_DOUBLE, FI_FLOAT_COMPLEX, FI_DOUBLE_COMPLEX, FI_LONG_DOUBLE,
FI_LONG_DOUBLE_COMPLEX
.TP
.B \f[I]msg_flags \- values OR\[cq]ed together\f[R]
For FT_FUNC_[SEND,WRITE,READ,ATOMIC]MSG: FI_REMOTE_CQ_DATA,
FI_COMPLETION
.TP
.B \f[I]rx_cq_bind_flags \- values OR\[cq]ed together\f[R]
FI_SELECTIVE_COMPLETION
.TP
.B \f[I]tx_cq_bind_flags \- values OR\[cq]ed together\f[R]
FI_SELECTIVE_COMPLETION
.TP
.B \f[I]rx_op_flags \- values OR\[cq]ed together\f[R]
FI_COMPLETION
.TP
.B \f[I]tx_op_flags \- values OR\[cq]ed together\f[R]
FI_COMPLETION
.TP
.B \f[I]test_flags \- values OR\[cq]ed together\f[R]
FT_FLAG_QUICKTEST
.SH HOW TO RUN TESTS
.IP "(1)" 4
Fabtests requires that libfabric be installed on the system, and at
least one provider be usable.
.IP "(2)" 4
Install fabtests on the system.
By default all the test executables are installed in /usr/bin directory
unless specified otherwise.
.IP "(3)" 4
All the client\-server tests have the following usage model:
.RS 4
.PP
fi_ [OPTIONS] start server fi_ connect to server
.RE
.SH COMMAND LINE OPTIONS
.PP
Tests share command line options where appropriate.
The following command line options are available for one or more test.
To see which options apply for a given test, you can use the `\-h' help
option to see the list available for that test.
.TP
.B \f[I]\-h\f[R]
Displays help output for the test.
.TP
.B \f[I]\-f \f[R]
Restrict test to the specified fabric name.
.TP
.B \f[I]\-d \f[R]
Restrict test to the specified domain name.
.TP
.B \f[I]\-p \f[R]
Restrict test to the specified provider name.
.TP
.B \f[I]\-e \f[R]
Use the specified endpoint type for the test.
Valid options are msg, dgram, and rdm.
The default endpoint type is rdm.
.TP
.B \f[I]\-D \f[R]
Allocate data buffers on the specified device, rather than in host
memory.
Valid options are ze and cuda.
*\-a
.IP \[bu] 2
: The name of a shared address vector.
This option only applies to tests that support shared address vectors.
.TP
.B \f[I]\-B \f[R]
Specifies the port number of the local endpoint, overriding the default.
.TP
.B \f[I]\-P \f[R]
Specifies the port number of the peer endpoint, overriding the default.
*\-s
.IP \[bu] 2
: Specifies the address of the local endpoint.
.TP
.B *\-F 
Specifies the address format.
.TP
.B *\-K
Fork a child process after initializing endpoint.
.TP
.B \f[I]\-b[=oob_port]\f[R]
Enables out\-of\-band (via sockets) address exchange and test
synchronization.
A port for the out\-of\-band connection may be specified as part of this
option to override the default.
.TP
.B \f[I]\-E[=oob_port]\f[R]
Enables out\-of\-band (via sockets) address exchange only.
A port for the out\-of\-band connection may be specified as part of this
option to override the default.
Cannot be used together with the `\-b' option.
.TP
.B \f[I]\-U\f[R]
Run fabtests with FI_DELIVERY_COMPLETE.
.TP
.B \f[I]\-I \f[R]
Number of data transfer iterations.
.TP
.B \f[I]\-Q\f[R]
Associated any EQ with the domain, rather than directly with the EP.
.TP
.B \f[I]\-w \f[R]
Number of warm\-up data transfer iterations.
.TP
.B \f[I]\-S \f[R]
Data transfer size or `all' for a full range of sizes.
By default a select number of sizes will be tested.
.TP
.B \f[I]\-l\f[R]
If specified, the starting address of transmit and receive buffers will
be aligned along a page boundary.
.TP
.B \f[I]\-m\f[R]
Use machine readable output.
This is useful for post\-processing the test output with scripts.
.TP
.B \f[I]\-t \f[R]
Specify the type of completion mechanism to use.
Valid values are queue and counter.
The default is to use completion queues.
.TP
.B \f[I]\-c \f[R]
Indicate the type of processing to use checking for completed
operations.
Valid values are spin, sread, and fd.
The default is to busy wait (spin) until the desired operation has
completed.
The sread option indicates that the application will invoke a blocking
read call in libfabric, such as fi_cq_sread.
Fd indicates that the application will retrieve the native operating
system wait object (file descriptor) and use either poll() or select()
to block until the fd has been signaled, prior to checking for
completions.
.TP
.B \f[I]\-o \f[R]
For RMA based tests, specify the type of RMA operation to perform.
Valid values are read, write, and writedata.
Write operations are the default.
.TP
.B \f[I]\-M \f[R]
For multicast tests, specifies the address of the multicast group to
join.
.TP
.B \f[I]\-v\f[R]
Add data verification check to data transfers.
.SH USAGE EXAMPLES
.SS A simple example
.IP
.nf
\f[C]
run server: <test_name> \-p <provider_name> \-s <source_addr>
    e.g.    fi_msg_rma \-p sockets \-s 192.168.0.123
run client: <test_name> <server_addr> \-p <provider_name>
    e.g.    fi_msg_rma 192.168.0.123 \-p sockets
\f[R]
.fi
.SS An example with various options
.IP
.nf
\f[C]
run server: fi_rdm_atomic \-p psm \-s 192.168.0.123 \-I 1000 \-S 1024
run client: fi_rdm_atomic 192.168.0.123 \-p psm \-I 1000 \-S 1024
\f[R]
.fi
.PP
This will run \[lq]fi_rdm_atomic\[rq] for all atomic operations with
.IP
.nf
\f[C]
\- PSM provider
\- 1000 iterations
\- 1024 bytes message size
\- server node as 123.168.0.123
\f[R]
.fi
.SS Run multinode tests
.IP
.nf
\f[C]
Server and clients are invoked with the same command:
    fi_multinode \-n <number of processes> \-s <server_addr> \-C <mode>

A process on the server must be started before any of the clients can be started
succesfully. \-C lists the mode that the tests will run in. Currently the options are
\f[R]
.fi
.PP
for rma and msg.
If not provided, the test will default to msg.
.SS Run fi_ubertest
.IP
.nf
\f[C]
run server: fi_ubertest
run client: fi_ubertest \-u /usr/share/fabtests/test_configs/sockets/quick.test 192.168.0.123
\f[R]
.fi
.PP
This will run \[lq]fi_ubertest\[rq] with
.IP
.nf
\f[C]
\- sockets provider
\- configurations defined in /usr/share/fabtests/test_configs/sockets/quick.test
\- server node as 192.168.0.123
\f[R]
.fi
.PP
The config files are provided in /test_configs for sockets, verbs, udp,
and usnic providers and distributed with fabtests installation.
.PP
For more usage options: fi_ubertest \-h
.SS Run the whole fabtests suite
.PP
A runscript scripts/runfabtests.sh is provided that runs all the tests
in fabtests and reports the number of pass/fail/notrun.
.IP
.nf
\f[C]
Usage: runfabtests.sh [OPTIONS] [provider] [host] [client]
\f[R]
.fi
.PP
By default if none of the options are provided, it runs all the tests
using
.IP
.nf
\f[C]
\- sockets provider
\- 127.0.0.1 as both server and client address
\- for small number of optiond and iterations
\f[R]
.fi
.PP
Various options can be used to choose provider, subset tests to run,
level of verbosity etc.
.IP
.nf
\f[C]
runfabtests.sh \-vvv \-t all psm 192.168.0.123 192.168.0.124
\f[R]
.fi
.PP
This will run all fabtests using
.IP
.nf
\f[C]
\- psm provider
\- for different options and larger iterations
\- server node as 192.168.0.123 and client node as 192.168.0.124
\- print test output for all the tests
\f[R]
.fi
.PP
For detailed usage options: runfabtests.sh \-h
.SH NOTES
.PP
To test FI_INT128/FI_UINT128 atomics, fabtests must be built with a
compiler that supports 128\-bit integers.
.PP
For providers that perform atomics in software (\f[I]e.g.\f[R] shm), the
availability of FI_INT128/FI_UINT128 atomics depends on building the
provider with a compiler and libraries that support 128\-bit integers
and atomics.
.SH AUTHORS
OpenFabrics.
